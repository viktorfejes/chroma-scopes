<canvas id="uiCanvas" width="800" height="600" style="border:1px solid #ccc;"></canvas>
<script>
    class Node {
        constructor({
            name,
            display = 'block',
            width = 0,
            height = 0,
            flexGrow = 0,
            flexDirection = 'column',
            mainAxisAlignment = 'start', // start, center, end, spaceBetween, spaceAround, spaceEvenly
            crossAxisAlignment = 'stretch', // start, center, end, stretch
            padding = 0,
            margin = 0,
            gap = 0,
            children = []
        }) {
            this.name = name;
            this.display = display;
            this.width = width;
            this.height = height;
            this.flexGrow = flexGrow;
            this.flexDirection = flexDirection;
            this.mainAxisAlignment = mainAxisAlignment;
            this.crossAxisAlignment = crossAxisAlignment;

            // Handle padding/margin as numbers or objects
            this.padding = this.parseSpacing(padding);
            this.margin = this.parseSpacing(margin);
            this.gap = gap;

            this.children = children;
            this.layout = {x: 0, y: 0, w: 0, h: 0};
            this.contentArea = {x: 0, y: 0, w: 0, h: 0}; // Area inside padding
        }

        parseSpacing(spacing) {
            if (typeof spacing === 'number') {
                return {top: spacing, right: spacing, bottom: spacing, left: spacing};
            }
            return {
                top: spacing.top || 0,
                right: spacing.right || 0,
                bottom: spacing.bottom || 0,
                left: spacing.left || 0
            };
        }

        get paddingHorizontal() {return this.padding.left + this.padding.right;}
        get paddingVertical() {return this.padding.top + this.padding.bottom;}
        get marginHorizontal() {return this.margin.left + this.margin.right;}
        get marginVertical() {return this.margin.top + this.margin.bottom;}
    }

    // Helper functions
    function clamp(x, min, max) {
        return Math.max(min, Math.min(x, max));
    }

    function getMainAxisSize(node, layout) {
        return node.flexDirection === 'row' ? layout.w : layout.h;
    }

    function getCrossAxisSize(node, layout) {
        return node.flexDirection === 'row' ? layout.h : layout.w;
    }

    // Measure Pass: constraints go down, sizes go up
    function layoutMeasure(node, minW, maxW, minH, maxH) {
        // Account for margin in available space
        const availableW = maxW - node.marginHorizontal;
        const availableH = maxH - node.marginVertical;

        let w = node.width || availableW;
        let h = node.height || availableH;

        if (node.display === 'flex' && node.children.length > 0) {
            // Content area (inside padding)
            const contentW = w - node.paddingHorizontal;
            const contentH = h - node.paddingVertical;

            let totalFlex = node.children.reduce((sum, c) => sum + (c.flexGrow || 0), 0);
            let fixedSize = 0;
            let flexChildren = [];

            // Calculate total gap space
            const totalGap = Math.max(0, (node.children.length - 1) * node.gap);

            // First pass: measure fixed-size children
            for (const child of node.children) {
                if (child.flexGrow > 0) {
                    flexChildren.push(child);
                } else {
                    // Fixed size child
                    if (node.flexDirection === 'row') {
                        const childMaxW = child.width || contentW;
                        const childMaxH = node.crossAxisAlignment === 'stretch' ? contentH : (child.height || contentH);
                        layoutMeasure(child, 0, childMaxW, 0, childMaxH);
                        fixedSize += child.layout.w + child.marginHorizontal;
                    } else {
                        const childMaxW = node.crossAxisAlignment === 'stretch' ? contentW : (child.width || contentW);
                        const childMaxH = child.height || contentH;
                        layoutMeasure(child, 0, childMaxW, 0, childMaxH);
                        fixedSize += child.layout.h + child.marginVertical;
                    }
                }
            }

            // Second pass: distribute remaining space among flex children
            const mainAxisContentSize = node.flexDirection === 'row' ? contentW : contentH;
            const remainingSpace = Math.max(0, mainAxisContentSize - fixedSize - totalGap);

            for (const child of flexChildren) {
                if (node.flexDirection === 'row') {
                    const childW = totalFlex > 0 ? (remainingSpace * (child.flexGrow / totalFlex)) : 0;
                    const childMaxH = node.crossAxisAlignment === 'stretch' ? contentH : (child.height || contentH);
                    layoutMeasure(child, 0, childW, 0, childMaxH);
                } else {
                    const childMaxW = node.crossAxisAlignment === 'stretch' ? contentW : (child.width || contentW);
                    const childH = totalFlex > 0 ? (remainingSpace * (child.flexGrow / totalFlex)) : 0;
                    layoutMeasure(child, 0, childMaxW, 0, childH);
                }
            }

            // If node size wasn't specified, calculate it from children
            if (!node.width) {
                if (node.flexDirection === 'row') {
                    const childrenWidth = node.children.reduce((sum, child) =>
                        sum + child.layout.w + child.marginHorizontal, 0) + totalGap;
                    w = childrenWidth + node.paddingHorizontal;
                }
            }

            if (!node.height) {
                if (node.flexDirection === 'column') {
                    const childrenHeight = node.children.reduce((sum, child) =>
                        sum + child.layout.h + child.marginVertical, 0) + totalGap;
                    h = childrenHeight + node.paddingVertical;
                }
            }
        }

        node.layout.w = clamp(w, minW, maxW);
        node.layout.h = clamp(h, minH, maxH);

        // Calculate content area
        node.contentArea = {
            x: 0, y: 0, // Will be set in position pass
            w: node.layout.w - node.paddingHorizontal,
            h: node.layout.h - node.paddingVertical
        };
    }

    // Position Pass: parent sets position
    function layoutPosition(node, originX, originY) {
        // Position including margin
        node.layout.x = originX + node.margin.left;
        node.layout.y = originY + node.margin.top;

        // Content area position (inside padding)
        node.contentArea.x = node.layout.x + node.padding.left;
        node.contentArea.y = node.layout.y + node.padding.top;

        if (node.display === 'flex' && node.children.length > 0) {
            positionFlexChildren(node);
        }
    }

    function positionFlexChildren(node) {
        const isRow = node.flexDirection === 'row';
        const children = node.children;
        const totalGap = Math.max(0, (children.length - 1) * node.gap);

        // Calculate total size of children along main axis
        const childrenMainSize = children.reduce((sum, child) => {
            const childSize = isRow ? (child.layout.w + child.marginHorizontal) : (child.layout.h + child.marginVertical);
            return sum + childSize;
        }, 0);

        const mainAxisSize = isRow ? node.contentArea.w : node.contentArea.h;
        const crossAxisSize = isRow ? node.contentArea.h : node.contentArea.w;
        const freeSpace = mainAxisSize - childrenMainSize - totalGap;

        // Calculate starting position and spacing based on main axis alignment
        let mainStart = isRow ? node.contentArea.x : node.contentArea.y;
        let spacing = 0;

        switch (node.mainAxisAlignment) {
            case 'center':
                mainStart += freeSpace / 2;
                break;
            case 'end':
                mainStart += freeSpace;
                break;
            case 'spaceBetween':
                spacing = children.length > 1 ? freeSpace / (children.length - 1) : 0;
                break;
            case 'spaceAround':
                spacing = freeSpace / children.length;
                mainStart += spacing / 2;
                break;
            case 'spaceEvenly':
                spacing = freeSpace / (children.length + 1);
                mainStart += spacing;
                break;
            // 'start' is default - no adjustment needed
        }

        let cursor = mainStart;

        for (const child of children) {
            let childMainPos = cursor;
            let childCrossPos;

            // Position along cross axis
            const crossStart = isRow ? node.contentArea.y : node.contentArea.x;
            const childCrossSize = isRow ? (child.layout.h + child.marginVertical) : (child.layout.w + child.marginHorizontal);

            switch (node.crossAxisAlignment) {
                case 'center':
                    childCrossPos = crossStart + (crossAxisSize - childCrossSize) / 2;
                    break;
                case 'end':
                    childCrossPos = crossStart + crossAxisSize - childCrossSize;
                    break;
                case 'stretch':
                case 'start':
                default:
                    childCrossPos = crossStart;
                    break;
            }

            // Set child position
            if (isRow) {
                layoutPosition(child, childMainPos, childCrossPos);
                cursor += child.layout.w + child.marginHorizontal + node.gap + spacing;
            } else {
                layoutPosition(child, childCrossPos, childMainPos);
                cursor += child.layout.h + child.marginVertical + node.gap + spacing;
            }
        }
    }

    // Render to canvas
    function renderNode(ctx, node) {
        // Draw margin (light red)
        if (node.marginHorizontal > 0 || node.marginVertical > 0) {
            ctx.fillStyle = 'rgba(255, 200, 200, 0.3)';
            ctx.fillRect(
                node.layout.x - node.margin.left,
                node.layout.y - node.margin.top,
                node.layout.w + node.marginHorizontal,
                node.layout.h + node.marginVertical
            );
        }

        // Draw main box
        const colors = {
            toolbar: '#4a90e2',
            sidebar: '#7ed321',
            canvas: '#f5a623',
            main: '#bd10e0',
            root: '#b8e986',
            card: '#50e3c2',
            button: '#d0021b'
        };

        ctx.fillStyle = colors[node.name] || '#e8e8e8';
        ctx.fillRect(node.layout.x, node.layout.y, node.layout.w, node.layout.h);

        // Draw padding (light blue)
        if (node.paddingHorizontal > 0 || node.paddingVertical > 0) {
            ctx.fillStyle = 'rgba(200, 200, 255, 0.2)';
            // contentArea is just the layout area with padding
            ctx.fillRect(node.contentArea.x, node.contentArea.y, node.contentArea.w, node.contentArea.h);
        }

        // Draw border
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        ctx.strokeRect(node.layout.x, node.layout.y, node.layout.w, node.layout.h);

        // Draw text
        ctx.fillStyle = '#000';
        ctx.font = '11px sans-serif';
        const text = `${node.name} (${Math.round(node.layout.w)}×${Math.round(node.layout.h)})`;
        ctx.fillText(text, node.layout.x + 2, node.layout.y + 12);

        for (const child of node.children) {
            renderNode(ctx, child);
        }
    }

    // Create more complex layout tree to demonstrate features
    const button1 = new Node({
        name: 'button',
        width: 80,
        height: 30,
        margin: 5,
        padding: {top: 5, right: 10, bottom: 5, left: 10}
    });

    const button2 = new Node({
        name: 'button',
        width: 100,
        height: 30,
        margin: 5,
        padding: 8
    });

    const card = new Node({
        name: 'card',
        width: 150,
        padding: 15,
        margin: 10,
        display: 'flex',
        flexDirection: 'column',
        gap: 10,
        children: [button1, button2]
    });

    const sidebar = new Node({
        name: 'sidebar',
        width: 200,
        padding: 10,
        display: 'flex',
        flexDirection: 'column',
        crossAxisAlignment: 'center',
        children: [card]
    });

    const canvas = new Node({
        name: 'canvas',
        flexGrow: 1,
        margin: {top: 0, right: 10, bottom: 10, left: 0},
        padding: 20
    });

    const main = new Node({
        name: 'main',
        display: 'flex',
        flexDirection: 'row',
        flexGrow: 1,
        gap: 10,
        padding: 10,
        children: [sidebar, canvas]
    });

    const toolbar = new Node({
        name: 'toolbar',
        height: 50,
        padding: {top: 10, right: 15, bottom: 10, left: 15},
        display: 'flex',
        flexDirection: 'row',
        mainAxisAlignment: 'spaceBetween',
        crossAxisAlignment: 'center'
    });

    const root = new Node({
        name: 'root',
        display: 'flex',
        flexDirection: 'column',
        width: 800,
        height: 600,
        children: [toolbar, main]
    });

    // Run layout
    layoutMeasure(root, 0, 800, 0, 600);
    layoutPosition(root, 0, 0);

    // Draw
    const canvasEl = document.getElementById('uiCanvas');
    const ctx = canvasEl.getContext('2d');
    ctx.clearRect(0, 0, 800, 600);
    renderNode(ctx, root);

    // Debug output
    console.log('Layout Results:');
    function printLayout(node, indent = 0) {
        const spaces = '  '.repeat(indent);
        const margin = `m:${node.margin.top},${node.margin.right},${node.margin.bottom},${node.margin.left}`;
        const padding = `p:${node.padding.top},${node.padding.right},${node.padding.bottom},${node.padding.left}`;
        console.log(`${spaces}${node.name}: ${node.layout.x},${node.layout.y} ${node.layout.w}×${node.layout.h} ${margin} ${padding}`);
        for (const child of node.children) {
            printLayout(child, indent + 1);
        }
    }
    printLayout(root);

    let idt;
    window.addEventListener("resize", (e) => {
        if (idt) clearTimeout(idt);
        idt = setTimeout(() => {
            canvasEl.width = document.body.clientWidth;
            canvasEl.height = window.innerHeight;

            root.width = canvasEl.width;
            root.height = canvasEl.height;
            layoutMeasure(root, 0, canvasEl.width, 0, canvasEl.height);
            layoutPosition(root, 0, 0);

            ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
            renderNode(ctx, root);
        }, 100);
    });
</script>
